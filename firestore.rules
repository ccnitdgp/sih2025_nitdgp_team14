
/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model for all private data,
 * while allowing public read access to general information like health camps and vaccination drives.
 * The primary goal is to ensure that a user can only ever access their own information, unless
 * they are a doctor, in which case they can access the data of patients assigned to them.
 *
 * Data Structure: All user data is stored under `/users/{userId}`. Private subcollections like
 * `healthRecords` are nested within this structure. For doctors, a `patients` subcollection
 * exists at `/users/{doctorId}/patients/{patientId}` which links them to their patients' data.
 * This structure is key to our security model.
 *
 * Key Security Decisions:
 * - User Enumeration is explicitly disallowed by disabling list access on the top-level `/users` collection.
 * - Public data collections (`vaccinationDrives`, `healthCamps`) are read-only for all users.
 * - All write operations on user-owned data require the user to be authenticated and their UID to match
 *   the `userId` in the document path.
 * - Doctors can read patient data (`/users/{patientId}`) ONLY IF a corresponding document exists in their
 *   own patient list (`/users/{request.auth.uid}/patients/{patientId}`). This is a critical security check.
 *
 * Denormalization for Authorization: The data structure is designed to be self-sufficient for authorization.
 * By nesting user-specific collections like `healthRecords` under `/users/{userId}`, we can write fast, simple
 * rules that rely only on the document path (`isOwner(userId)`) or the doctor-patient link. This avoids
 * slow and costly `get()` calls to other documents to verify ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // =====================================================================
    // Helper Functions
    // =====================================================================

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the document's userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Verifies ownership for a document that already exists.
     * Crucial for secure update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the requesting user is a doctor.
     */
    function isDoctor() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'doctor';
    }

    /**
     * Checks if the requesting user is the assigned doctor for the given patient (userId).
     * This is the core of the doctor-patient access control.
     */
    function isAssignedDoctor(patientId) {
      return isDoctor() && exists(/databases/$(database)/documents/users/$(request.auth.uid)/patients/$(patientId));
    }

    /**
     * Validates that the UserProfile 'id' field matches the document ID on create.
     */
    function userProfileIdMatchesDocIdOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Validates that a subcollection document's internal 'userId' field
     * matches the {userId} from the path upon creation.
     */
    function hasCorrectUserIdOnCreate(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Enforces that the internal 'userId' field of a subcollection document
     * cannot be changed after creation.
     */
    function userIdIsImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }
    
    /**
     * Ensures the 'id' field of a UserProfile cannot be changed on update.
     */
    function userProfileIdIsImmutable() {
      return request.resource.data.id == resource.data.id;
    }


    // =====================================================================
    // User Data Collections
    // =====================================================================

    match /users/{userId} {
      allow get: if isOwner(userId) || isAssignedDoctor(userId);
      allow list: if false; // Prevent listing all users
      allow create: if isOwner(userId) && userProfileIdMatchesDocIdOnCreate(userId);
      allow update: if isOwner(userId) && userProfileIdIsImmutable();
      allow delete: if isOwner(userId);

      /**
       * @description A doctor's list of their patients. Only the doctor can manage this list.
       */
      match /patients/{patientId} {
        allow read, write: if isOwner(userId);
      }
      
      // THIS IS THE CRITICAL FIX: This rule applies to the COLLECTION, not just the documents.
      // It allows a doctor to list the patients associated with them.
      allow list: if isOwner(userId) && isDoctor();


      /**
       * @description Manages a user's private health records.
       * Access is granted to the patient themselves or their assigned doctor.
       */
      match /healthRecords/{healthRecordId} {
        allow read, list: if isOwner(userId) || isAssignedDoctor(userId);
        allow create: if (isOwner(userId) || isAssignedDoctor(userId)) && hasCorrectUserIdOnCreate(userId);
        allow update, delete: if (isOwner(userId) || isAssignedDoctor(userId)) && userIdIsImmutable();
      }

      /**
       * @description Manages a user's private medical notifications.
       */
      match /notifications/{notificationId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && hasCorrectUserIdOnCreate(userId);
        allow update, delete: if isOwner(userId) && userIdIsImmutable();
      }
    }

    // =====================================================================
    // Public Data Collections
    // =====================================================================

    match /vaccinationDrives/{vaccinationDriveId} {
      allow read: if true;
      allow write: if false; // Secure by default
    }

    match /healthCamps/{healthCampId} {
      allow read: if true;
      allow write: if false; // Secure by default
    }
  }
}
